#### 特性

##### ACID

```
原子性：
	一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样

一致性：
	在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作

隔离性：
	数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。

持久性：
	事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。
```



![img](https://pic4.zhimg.com/80/v2-2e1a7203478165890e2d09f36cb39857_720w.jpg)



##### 事务控制语句：

```
BEGIN或START TRANSACTION 显式开启一个事务
COMMIT或COMMIT WORK 提交事务，并使已对数据库进行的所有修改成为永久性的
ROLLBACK也可以使用ROLLABACK WORK 回滚并结束用户的事务，并撤销正在进行的所有未提交的修改
SAVEPOINT identifier 在事务中创建一个保存点，一个事务
RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常
ROLLBACK TO identifier 把事务回滚到标记点
SET TRANSACTION 用来设置事务的隔离级别。InnoDB存储引擎提供事务的
```

##### 脏读

```
脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。
```

##### 可重复读

```
可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的。通常针对数据更新（UPDATE）操作。
```

##### 不可重复读

```
对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据更新（UPDATE）操作。
```

##### 幻读

```
幻读是针对数据插入（INSERT）操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。
```



##### 事务隔离级别

```
1.读未提交READ UNCOMMITTED
2.读提交READ COMMITTED
3.可重复读（Mysql默认级别） REPEATABLE READ
4.串行化 SERIALIZABLE
```



任何事务对数据的修改都会第一时间暴露给其他事务，即使事务还没有提交



##### 读未提交

```
	读未提交，其实就是可以读到其他事务未提交的数据，但没有办法保证你读到的数据最终一定是提交后的数据，如果中间发生回滚，那就会出现脏数据问题，读未提交没办法解决脏数据问题。更别提可重复读和幻读了，想都不要想。

	set global transaction isolation level read uncommitted;
```

##### 读提交

```
	既然读未提交没办法解决脏数据问题，那么就有了读提交。读提交就是一个事务只能读到其他事务已经提交过的数据，也就是其他事务调用 commit 命令之后的数据。那脏数据问题迎刃而解了。
	读提交事务隔离级别是大多数流行数据库的默认事务隔离界别，比如 Oracle，但是不是 MySQL 的默认隔离界别。
	
	set global transaction isolation level read committed;
	
	读提交解决了脏读的问题，但是无法做到可重复读，也没办法解决幻读。
```

##### 可重复读

```
	可重复是对比不可重复而言的，上面说不可重复读是指同一事物不同时刻读到的数据值可能不一致。而可重复读是指，事务不会读到其他事务对已有数据的修改，及时其他事务已提交，也就是说，事务开始时读到的已有数据是什么，在事务提交前的任意时刻，这些数据的值都是一样的。但是，对于其他事务新插入的数据是可以读到的，这也就引发了幻读问题
	
	set global transaction isolation level repeatable read;

	要说明的是，当你在 MySQL 中测试幻读的时候，并不会出现上图的结果，幻读并没有发生，MySQL 的可重复读隔离级别其实解决了幻读问题，这会在后面的内容说明
```

##### 串行化

```
串行化是4种事务隔离级别中隔离效果最好的，解决了脏读、可重复读、幻读的问题，但是效果最差，它将事务的执行变为顺序执行，与其他三个隔离级别相比，它就相当于单线程，后一个事务的执行必须等待前一个事务结束。
```

##### 并发写问题（解决方式：行锁）

```
	假设事务A执行 update 操作， update 的时候要对所修改的行加行锁，这个行锁会在提交之后才释放。而在事务A提交之前，事务B也想 update 这行数据，于是申请行锁，但是由于已经被事务A占有，事务B是申请不到的，此时，事务B就会一直处于等待状态，直到事务A提交，事务B才能继续执行，如果事务A的时间太长，那么事务B很有可能出现超时异常
 ##有索引加锁：
		update user set age=11 where id = 1
	id 是这张表的主键，是有索引的情况，那么 MySQL 直接就在索引数中找到了这行数据，然后干净利落的加上行锁就可以了。
 ##无索引加锁：
		update user set age=11 where age=10
    表中并没有为 age 字段设置索引，所以， MySQL 无法直接定位到这行数据。那怎么办呢，当然也不是加表锁了。MySQL 会为这张表中所有行加行锁，没错，是所有行。但是呢，在加上行锁后，MySQL 会进行一遍过滤，发现不满足的行就释放锁，最终只留下符合条件的行。虽然最终只为符合条件的行加了锁，但是这一锁一释放的过程对性能也是影响极大的。所以，如果是大表的话，建议合理设计索引，如果真的出现这种情况，那很难保证并发度。
```



##### 解决幻读（解决方式：Next-Key）

```
MySQL 已经在可重复读隔离级别下解决了幻读的问题。
前面刚说了并发写问题的解决方式就是行锁，而解决幻读用的也是锁，叫做间隙锁，MySQL 把行锁和间隙锁合并在一起，解决了并发写和幻读的问题，这个锁叫做 Next-Key锁

这是有索引的情况，如果 age 不是索引列，那么数据库会为整个表加上间隙锁。所以，如果是没有索引的话，不管 age 是否大于等于30，都要等待事务A提交才可以成功插入
```



##### 指令

```
#查询正在运行的事务
select * from information_schema.innodb_trx;
#修改事务隔离级别（设置完成后，只对之后新起的 session 才起作用，对已经启动 session 无效。如果用 shell 客户端那就要重新连接 MySQL，如果用 Navicat 那就要创建新的查询窗口）
set global transaction isolation level read committed;

```



##### Mysql实现可重复读

```
为了解决不可重复读，或者为了实现可重复读，MySQL 采用了 MVVC (多版本并发控制) 的方式。
为了解决不可重复读，或者为了实现可重复读，MySQL 采用了 MVVC (多版本并发控制) 的方式。

我们在数据库表中看到的一行记录可能实际上有多个版本，每个版本的记录除了有数据本身外，还要有一个表示版本的字段，记为 row trx_id，而这个字段就是使其产生的事务的 id，事务 ID 记为 transaction id，它在事务开始的时候向事务系统申请，按时间先后顺序递增。


按照上面这张图理解，一行记录现在有 3 个版本，每一个版本都记录这使其产生的事务 ID，比如事务A的transaction id 是100，那么版本1的row trx_id 就是 100，同理版本2和版本3。

在上面介绍读提交和可重复读的时候都提到了一个词，叫做快照，学名叫做一致性视图，这也是可重复读和不可重复读的关键，可重复读是在事务开始的时候生成一个当前事务全局性的快照，而读提交则是每次执行语句的时候都重新生成一次快照。

对于一个快照来说，它能够读到那些版本数据，要遵循以下规则：

当前事务内的更新，可以读到；
版本未提交，不能读到；
版本已提交，但是却在快照创建后提交的，不能读到；
版本已提交，且是在快照创建前提交的，可以读到；
利用上面的规则，再返回去套用到读提交和可重复读的那两张图上就很清晰了。还是要强调，两者主要的区别就是在快照的创建上，可重复读仅在事务开始是创建一次，而读提交每次执行语句的时候都要重新创建一次。
```

##### 自动提交

```
	mysql默认采用自动提交模式（每个查询都被当作一个事务执行提交操作）
	一些命令执行之前会强制执行commit提交当前的活动日志：DDl、lock tables等
```

##### 显式锁定和隐式锁定

```
InnoDB会根据隔离级别在需要的时候自动加锁，这称谓隐式加锁
select .... lock in share mode 显式共享锁
select .... for update	  显式排它锁

除了事务中禁用了自动提交，可以使用lock tables之外，其他任何时候都不要显式执行lock tables,不管使用的是什么存储引擎
```

##### 多版本并发控制（MVCC）

```
乐观并发控制
悲观并发控制

	在InnoDB中，使用乐观并发控制来实现MVCC。在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期(或者被删除)。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。

    (1)MVCC的具体操作

    在可重复读事务隔离(RR)级别下，MVCC的具体操作如下：

    SELECT语句

    InnoDB会根据以下两个条件检查每行记录：

    (a)创建版本号<=当前事务版本号

    这样可以确保事务读取的行，要么在事务开始前已经存在，要么是事务自身插入或者修改过的。

    (b)删除版本号为空，或者，删除版本号>当前事务版本号

    这样可以确保事务读取到的行在事务开始之前未被删除。

    INSERT语句

    保存当前事务版本号为行的创建版本号。

    DELETE语句

    保存当前事务版本号为行的删除版本号。

    UPDATE语句

    插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行。

    通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。

	MVCC只在"可重复读"和"读提交"两个隔离级别下工作，其他两个隔离级别都和MVCC不兼容。因为"读未提交"总是读取最新的数据行，而不是符合当前事务版本的数据行。而串行则会对所有读取的行都加锁
```



##### 总结

```
MySQL 的 InnoDB 引擎才支持事务，其中可重复读是默认的隔离级别。

读未提交和串行化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执行，效率太差。

读提交解决了脏读问题，行锁解决了并发更新的问题。并且 MySQL 在可重复读级别解决了幻读问题，是通过行锁和间隙锁的组合 Next-Key 锁实现的。
```

