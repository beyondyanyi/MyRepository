##### 概要

事务的实现是基于数据库的存储引擎

mysql中支持事务的存储引擎有InnoDB和NDB

InnoDB事务日志包括redo log和undo log



##### redo log(重做日志)

​		通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样，它用来恢复提交后的物理数据页，且只能恢复到最后一次提交的位置。

```
	包括两部分：一是内存中的日志缓存（redo log buffer），该部分日志是易失性的；二是磁盘上的重做日志文件（redo log file），该部分日志是持久的
	在概念上，InnoDB 通过force log at commit机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。
	了确保每次日志都能写入到事务日志文件中，在每次将log buffer中的日志写入日志文件的过程中都会调用一次操作系统的fsync操作（即fsync()系统调用）。因为 MariaDB/MySQL 是工作在用户空间的，MariaDB/MySQL 的log buffer处于用户空间的内存中。要写入到磁盘上的log file中（redo:ib_logfileN文件、undo:share tablespace或.ibd文件），中间还要经过操作系统内核空间的os buffer，调用fsync()的作用就是将os buffer中的日志刷到磁盘上的log file中
```



##### undo log（回滚日志）

​		用来回滚行记录到某个版本，`undo log`一般是逻辑日志，根据每行记录进行记录。

```
	undo log主要为事务的回滚服务。在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作
	  以下是undo+redo事务的简化过程

        假设有2个数值，分别为A和B,值为1，2

        1. start transaction;

        2. 记录 A=1 到undo log;

        3. update A = 3；

        4. 记录 A=3 到redo log；

        5. 记录 B=2 到undo log；

        6. update B = 4；

        7. 记录B = 4 到redo log；

        8. 将redo log刷新到磁盘

        9. commit

	在1-8的任意一步系统宕机，事务未提交，该事务就不会对磁盘上的数据做任何影响。如果在8-9之间宕机，恢复之后可以选择回滚，也可以选择继续完成事务提交，因为此时redo log已经持久化。若在9之后系统宕机，内存映射中变更的数据还来不及刷回磁盘，那么系统恢复之后，可以根据redo log把数据刷回磁盘。
        
	所以，redo log其实保障的是事务的持久性和一致性，而undo log则保障了事务的原子性。

```



##### redo log和二进制日志的区别

```
	二进制日志相关内容，可以参考「MariaDB/MySQL 的二进制日志」这篇文章。
	redo log不是二进制日志。虽然二进制日志中也记录了 InnoDB 表的很多操作，也能实现重做的功能，但是它们之间有很大区别。
	二进制日志是在存储引擎的上层产生的，不管是什么存储引擎，对数据库进行了修改都会产生二进制日志。而redo log是 InnoDB 层产生的，只记录该存储引擎中表的修改。并且二进制日志先于redo log被记录。具体的见后文group commit小结。
二进制日志记录操作的方法是逻辑性的语句。即便它是基于行格式的记录方式，其本质也还是逻辑的 SQL 设置，如该行记录的每列的值是多少。而redo log是在物理格式上的日志，它记录的是数据库中每个页的修改。
	二进制日志只在每次事务提交的时候一次性写入缓存中的日志“文件”（对于非事务表的操作，则是每次执行语句成功后就直接写入）。而redo log在数据准备修改前写入缓存中的redo log中，然后才对缓存中的数据执行修改操作；而且保证在发出事务提交指令时，先向缓存中的redo log写入日志，写入完成后才执行提交动作。
因为二进制日志只在提交的时候一次性写入，所以二进制日志中的记录方式和提交顺序有关，且一次提交对应一次记录。而redo log中是记录的物理页的修改，redo log文件中同一个事务可能多次记录，最后一个提交的事务记录会覆盖所有未提交的事务记录。例如事务T1，可能在redo log中记录了T1-1、T1-2、T1-3和T1*共 4 个操作，其中T1*表示最后提交时的日志记录，所以对应的数据页最终状态是T1*对应的操作结果。而且redo log是并发写入的，不同事务之间的不同版本的记录会穿插写入到redo log文件中，例如	   可能redo log的记录方式为T1-1、T1-2、T2-1、T2-2、T2*、T1-3和T1* 。
事务日志记录的是物理页的情况，它具有幂等性，因此记录日志的方式极其简练。幂等性的意思是多次操作前后状态是一样的，例如新插入一行后又删除该行，前后状态没有变化。而二进制日志记录的是所有影响数据的操作，记录的内容较多。例如插入一行记录一次，删除该行又记录一次。
```

