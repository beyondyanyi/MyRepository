1.Shiro三大概念：
	Subject、SecurityManager、Realms
	
	Subject:主角，当前参与应用安全部分的主角。可以是任何东西。所有Subject都需要SecurityManager
	SecurityManager:安全管理员，核心架构。当我们与Subject进行交互的时候，实际上是SecurityManager在背后帮你举起
					Subject来做一些安全操作
	Realms:连接桥，

2.RBAC和RBAC新解
	Resource base access control  基于资源的权限控制
	Role base access control      基于角色的权限控制


3.Shiro授权
 Shiro三种授权方式
	1.编程式
	2.注解式
	3.jsp/gsp标签式

	(1).基于角色的访问控制（隐式角色）
		1.在ini配置文件配置用户拥有的角色(shiro-role.ini)
			[user]
			zhang=123,role1,role2


			规则："用户名=密码，角色1，角色2"

		2.判断某个用户是否有某个角色/某些权限  
		     subject.hasRole()
		     subject.hasRoles()
		     subject.hasAllRoles()

		     下面没有会抛出异常
		     subject.checkRole()
		     subject.checkRoles()
		     subject.checkAllRoles()

	(2).基于资源的访问控制（显示角色）
		1.在ini配置文件配置用户拥有的角色及角色-权限关系(shiro-permission.ini)
		[user]
		zhang=123,role1,role2
		admin=123,role1
		[roles]
		role1=user:create,user:update
		role2=user:create,user:delete


		规则："角色=权限1,权限2"


		2.判断某个用户是否有某个权限/所有权限
		subject.isPermitted()
		subject.isPermittedAll()

		下面没有会抛异常
		subject.checkPermission()
		subject.checkPermissions()



	(3.)Permission
		字符串通配符权限
			规则："资源标识符：操作：对象实例ID"

		1.单个资源单个权限
		   subject.checkPermissions("system:user:update");
		2.单个资源多个权限
			   role4=system:user:update,system:user:delete
			   可简写为
			   role4=system:user:update,delete
				
			   通过代码判断：
			   subject.checkPermissions("system:user:update,delete");
			  
		3.单个资源全部权限
		    role5=system:user:create,update,delete,view
	            判断
		    subject.checkPermissions("system:user:create,delte,view,update");

		    role5=system:user:*
		    或简写为
		    role5=system:user
		    判断
		    subject.checkPermissions("system:user:*");
		    subject.checkPermissions("system:user");

		 4.所有资源所有权限
		   role6=*:view
		   判断
		   subject.checkPermissions("user:view");

		 5.实例级别的权限
			（1）单个实例单个权限
			     role7=user:view:1
			     对资源user的1实例拥有view权限
			  
			     判断
			     subject.checkPermissions("user:view:1");
			 (2)单个实例多个权限
			     role7=user:update,delete:1
			     对资源user的1实例拥有update、delete权限

			     判断
			     subject.checkPermissions("user:delete,update:1");
			    
			  (3)所有实例单个权限
			     role7=user:auth:*
			     对资源user的实例1拥有所有权限

			     判断
			     subject.checkPermisssions("user:auth:1","user:auth:2");

			  (4)所有实例所有权限
			     role7=user:*:*
			     对资源user的1实例拥有所有权限

			     判断
			     subject.checkPermissions("user:view:1","user:auth:2");


		6.Shiro对权限字符串缺失部分的处理
			后缀匹配需指定前缀
		7.WildcardPermission
			subject.checkPermission("menu:view:1");
			subject.checkPermission(new WildcardPermission("menu:view:1"));

		8.授权流程：
			（1）调用subject.isPermitted*/hasRole*接口，其委托给SecurityManager，而SecurityManager委托给Authorizer
			 (2) Authorizer是真正的授权者
			 (3) 在进行授权之前，其会调用相应的Realm获取Subject相应的角色/权限用于匹配传入的角色/权限
			 (4) Authorizer会判断Realm的角色/权限是否和传入的匹配，如果有多个Realm,会委托给ModularRealmAuthorizer进行循环判断，如果匹配isPermitted*/hasRole,会返回true,否则返回false表示授权失败



			可通过如下ini的配置更改Authorizer实现：
			  authorizer=org.apache.shiro.authz.ModularRealmAuthorizer
			  securityManager.authorizer=$authorizer


4.Shiro Ini配置
	1.根对象SecurityManager
		1.纯Java代码写法
			DefaultSecurityManager securityManager = new DefaultSecurityManager();
			//设置authenticator
			ModularRealmAuthenticator authenticator = new ModularRealmAuthenticator();
			authenticator.setAuthenticationStrategy(new AtLeastOneSuccessfulStrategy());
			securityManager.setAuthenticator(authenticator);
			//设置authorizer
			ModularRealmAuthorizer authorizer = new ModularRealmAuthorizer();
			authorizer.setPermissionResolver(new WildcardPermissionResolver());
			securityManager.setAuthorizer(authorizer);
			//设置Realm
			DruidDataSource ds = new DruidDataSource();
			ds.setDriverClassName("com.mysql.jdbc.Driver");
			ds.setUrl("jdbc:mysql://localhost:3306/shiro");
			ds.setUsername("root");
			ds.setPassword("");
			JdbcRealm jdbcRealm = new JdbcRealm();
			jdbcRealm.setDataSource(ds);
			jdbcRealm.setPermissionsLookupEnabled(true);
			securityManager.setRealms(Arrays.asList((Realm) jdbcRealm));
			//将SecurityManager设置到SecurityUtils 方便全局使用
			SecurityUtils.setSecurityManager(securityManager);
			Subject subject = SecurityUtils.getSubject();
			UsernamePasswordToken token = new UsernamePasswordToken("zhang", "123");
			subject.login(token);
			Assert.assertTrue(subject.isAuthenticated());

		2.等价的INI配置（shiro-config.ini）
			[main]
			\#authenticator
			authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticator
			authenticationStrategy=org.apache.shiro.authc.pam.AtLeastOneSuccessfulStrategy
			authenticator.authenticationStrategy=$authenticationStrategy
			securityManager.authenticator=$authenticator
			\#authorizer
			authorizer=org.apache.shiro.authz.ModularRealmAuthorizer
			permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolver
			authorizer.permissionResolver=$permissionResolver
			securityManager.authorizer=$authorizer
			\#realm
			dataSource=com.alibaba.druid.pool.DruidDataSource
			dataSource.driverClassName=com.mysql.jdbc.Driver
			dataSource.url=jdbc:mysql://localhost:3306/shiro
			dataSource.username=root
			dataSource.password=123456
			jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm
			jdbcRealm.dataSource=$dataSource
			jdbcRealm.permissionsLookupEnabled=true
			securityManager.realms=$jdbcRealm


			从shiro-config.ini获取相应的securityManager实例：
				Factory<org.apache.shiro.mgt.SecurityManager> factory =new IniSecurityManagerFactory("classpath:shiro-config.ini");
				org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance();
				//将SecurityManager设置到SecurityUtils 方便全局使用
				SecurityUtils.setSecurityManager(securityManager);
				Subject subject = SecurityUtils.getSubject();
				UsernamePasswordToken token = new UsernamePasswordToken("zhang", "123");
				subject.login(token);
				Assert.assertTrue(subject.isAuthenticated());



	2.ini配置
		
		[main]部分
		  提供了对根对象securityManager及其依赖对象的配置

			创建对象
				securityManager=org.apache.shiro.mgt.DefaultSecurityManager
			常量值setter注入
				dataSource.driverClassName=com.mysql.jdbc.Driver
			对象引用setter注入
				authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticator
				authenticationStrategy=org.apache.shiro.authc.pam.AtLeastOneSuccessfulStrategy
				authenticator.authenticationStrategy=$authenticationStrategy
				securityManager.authenticator=$authenticator
			嵌套属性setter注入
				securityManager.authenticator.authenticationStrategy=$authenticationStrategy
			byte数组setter注入
				\#base64 byte[]
				authenticator.bytes=aGVsbG8=
				\#hex byte[]
				authenticator.bytes=0x68656c6c6f
			Array/Set/List setter注入
				authenticator.array=1,2,3
				authenticator.set=$jdbcRealm,$jdbcRealm
			Map setter注入
				authenticator.map=$jdbcRealm:$jdbcRealm,1:1,key:abc
			实例化/注入顺序
				realm=Realm1
				realm=Realm12
				authenticator.bytes=aGVsbG8=
				authenticator.bytes=0x68656c6c6f&nbsp; 
				后面的覆盖前面的

		[users]部分
			
		[roles]部分

		[urls]部分
			配置url及相应的拦截器之间的关系，格式："url=拦截器[参数],拦截器[参数]"

			[urls]
			/admin/** = authc, roles[admin], perms["permission1"]


5.Shiro编码加密
	编码/加密
		在涉及到密码存储问题上,应该加密/生成密码摘要存储，生成不可逆的摘要方式存储
	编码/解密
		Shiro提供了base64和16进制字符串编码/解码的api支持，方便一些编码解码操作。Shiro内部的一些数据的存储/表示都使用了base64和16进制字符串
		
		base64编码、解码
		String str = "hello";
		String base64Encoded = Base64.encodeToString(str.getBytes());
		String str2 = Base64.decodeToString(base64Encoded);
		Assert.assertEquals(str, str2);


		16进制编码、解码
		tring str = "hello";
		String base64Encoded = Hex.encodeToString(str.getBytes());
		String str2 = new String(Hex.decode(base64Encoded.getBytes()));
		Assert.assertEquals(str, str2);


	散列算法：
		散列算法一般用于生成数据的摘要信息，是一种不可逆的算法，一般适合存储密码之类的数据，常见的散列算法
		如MD5、SHA等

		String str = "hello";
		String salt = "123";
		String md5 = new Md5Hash(str, salt).toString();

		String str = "hello";
		String salt = "123";
		String sha1 = new Sha256Hash(str, salt).toString();

		String str = "hello";
		String salt = "123";
		//内部使用MessageDigest
		String simpleHash = new SimpleHash("SHA-1", str, salt).toString()


	加密/解密
		shiro提供对称式加密/解密算法的支持（AES、Blowfish等）

		AES算法实现：	
			AesCipherService aesCipherService = new AesCipherService();
			aesCipherService.setKeySize(128); //设置key长度
			//生成key
			Key key = aesCipherService.generateNewKey();
			String text = "hello";
			//加密
			String encrptText = 
			aesCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex();
			//解密
			String text2 =
			 new String(aesCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes());
			Assert.assertEquals(text, text2);
	
	PasswordService/CredentialsMatcher
		Shiro 提供了 PasswordService 及 CredentialsMatcher 用于提供加密密码及验证密码服务。

	DefaultPasswordService 配合 PasswordMatcher 实现简单的密码加密与验证服务

	HashedCredentialsMatcher 实现密码验证服务

6.Shiro Realm
	Realm


7.Shiro Web集成
	与web集成：
		Shiro 提供了与 Web 集成的支持，其通过一个 ShiroFilter 入口来拦截需要安全控制的 URL，然后进行相应的控制，ShiroFilter 类似于如 Strut2/SpringMVC 这种 web 框架的前端控制器，其是安全控制的入口点，其负责读取配置（如 ini 配置文件），然后判断 URL 是否需要登录 / 权限等工作。


	准备环境：
		1.创建webapp应用
		2.依赖
			<dependency>
			    <groupId>javax.servlet</groupId>
			    <artifactId>javax.servlet-api</artifactId>
			    <version>3.0.1</version>
			    <scope>provided</scope>
			</dependency>
			<dependency>
			    <groupId>org.apache.shiro</groupId>
			    <artifactId>shiro-web</artifactId>
			    <version>1.2.2</version>
			</dependency>
		3.ShiroFilter入口
			shiro1.2及以后版本的配置方式：
				<listener>
				   <listener-class>org.apache.shiro.web.env.EnvironmentLoaderListener</listener-class>
				</listener>

				<context-param>
				   <param-name>shiroEnvironmentClass</param-name>
				   <param-value>org.apache.shiro.web.env.IniWebEnvironment</param-value>
				</context-param>
				<context-param>
				   <param-name>shiroConfigLocations</param-name>
				   <param-value>classpath:shiro.ini</param-value>
			        </context-param>


			shiroConfigLocations 默认是 “/WEB-INF/shiro.ini”，IniWebEnvironment 默认是先从 / WEB-INF/shiro.ini 加载，如果没有就默认加载 classpath:shiro.ini。


		4.与Spring集成
			<filter>
			    <filter-name>shiroFilter</filter-name>
			    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
			    <init-param>
				<param-name>targetFilterLifecycle</param-name>
				<param-value>true</param-value>
			    </init-param>
			</filter>
			<filter-mapping>
			    <filter-name>shiroFilter</filter-name>
			    <url-pattern>/*</url-pattern>
			</filter-mapping>




			<bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
			<property name="securityManager" ref="securityManager"/>
			<!—忽略其他，详见与Spring集成部分 -->
			</bean>