1.模式
	模式是一条由三部分组成的规则：
			一个特定环境+一个问题+一个解决方案
	核心思想：
			进行设计的复用
			
2.设计模式
		描述了定制化的相互通信的对象和类，以解决特定环境中的通用设计问题
3.体系结构模式
		对系统的高层设计，是从一个较高的层次来考虑组成系统的构建。又被称为架构模式、体系结构风格
		
		
		
体系结构模式是高层模式
设计模式是中层模式
实现架构模式时可能采用多种设计模式



一：单例模式
	定义：确保一个类仅拥有一个唯一的实例，并且提供一个全局的访问点
	
	
	1.将构造方法私有化
	2.在类中声明类的实例，并将实例声明为静态
	3.对外公布一个获取该实例的方法
	##懒汉式
	public class Singleton {  
		private Singleton() {}  
		private static Singleton single=null;  
    //静态工厂方法（线程不安全）  
		public static Singleton getInstance() {  
			 if (single == null) {    
				 single = new Singleton();  
			 }    
			return single;  
		}  
	}
	
	
	#同步
	 public static synchronized Singleton getInstance() {  
             if (single == null) {    
                 single = new Singleton();  
             }    
            return single;  
    }
	
	#双重检查锁定
	public static Singleton getInstance() {  
        if (singleton == null) {    
            synchronized (Singleton.class) {    
               if (singleton == null) {    
                  singleton = new Singleton();   
               }    
            }    
        }    
        return singleton;   
    } 
	
	##静态内部类
	public class Singleton {    
		private static class LazyHolder {    
		   private static final Singleton INSTANCE = new Singleton();    
		}    
		private Singleton (){}    
		public static final Singleton getInstance() {    
		   return LazyHolder.INSTANCE;    
		}    
	} 
	
	
	//饿汉式（天生线程安全）
	public class Singleton1 {  
		private Singleton1() {}  
		private static final Singleton1 single = new Singleton1();  
		//静态工厂方法   
		public static Singleton1 getInstance() {  
			return single;  
		}  
	}
	
} 


单例模式使用场景：
	1.要求生成唯一序列号的环境
	2.在整个项目中需要一个共享访问点或共享数据
	3.创建一个对象需要消耗的资源过多
	4.需要定义大量的静态常量和静态方法

二：好的设计原则：
	单一职责原则：
		高内聚性原则
		避免相同的职责分散到不同的类中实现
		避免一个类承担过多的职责
	开闭原则：
		Open:模块的行为必须是开放的、支持扩展的，而不是僵化的
		Closed:在对模块的功能进行扩展使，不应该影响或大规模地影响已有的程序模块
		抽象化是开闭原则的关键
		对扩展开放，对修改关闭
	里氏代换原则：所有引用基类的地方必须能透明地使用其子类的对象，通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常
			里氏替换原则为继承定义的规范：
					1.子类必须完全实现父类的方法
					2.子类可以有自己的个性
					3.覆盖或实现父类的方法时输出参数可以被放大
					4.覆盖或实现父类的方法时输出结果可以被缩小
					
					1.子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
					2.子类中可以增加自己特有的方法
					3.当子类的方法重载父类的方法时，方法的前置条件（方法的形参）要比父类方法的输入参数更宽松
					4.当子类的方法实现父类的抽象方法时，方法的后置条件（方法的返回值）要比父类更严格
					
					
			里氏替换原则是对开闭原则的补充
	依赖倒转原则：
		高层模块不应该依赖低层模块，两者都应该依赖抽象
		抽象不应该依赖细节
		细节应该依赖抽象
		也可以说高层模块，低层模块，细节都应该依赖抽象
	接口隔离原则：
		一个类对另外一个类的依赖性应当是建立在最小的接口上
		客户端不应该依赖哪些它不需要的接口（方法）
	合成复用原则：
		尽量使用对象组合，而不是继承来达到复用目的
		一个新的对象通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象
		新对象通过委派调用已有对象的方法达到复用其已有功能的目的
		
		简单说：要尽量使用组合/聚合关系（黑箱复用），少用继承（白箱复用）！
		
		黑箱复用：
			1.第一种：不用继承，类中直接新增需要复用的类的实例即可
			2.在第一种的基础上将类属性换成接口
		白箱复用：
			直接继承，耦合度高
	迪米特原则：
		要求一个软件实体应当尽可能少的与其他实体发生相互作用
		简单说：
			最少知识原则；
				不要和“陌生人”说话
				只与你的直接朋友通信
				每一个软件单位对其他的单位都只有最少的知识，而且局限于哪些与本单位密切相关的软件单位
		如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用
		
		
		
三：策略模式：
	1.将每一个一系列的算法封装起来
	2.而且使它们还可以相互替换




四：工厂方法模式：
	简单工厂模式、工厂模式、抽象工厂模式
	定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类
	
	抽象工厂模式：
		优点：封装性；产品族内的约束为非公开状态
		缺点：产品族扩展非常困难
		使用场景：一个对象族（或是一组没有任何关系的对象）都有相同的约束，则可以使用抽象工厂模式
		
		
五：模板方法模式：
			
		
		
		
		
		
		
		
		
		
		
		