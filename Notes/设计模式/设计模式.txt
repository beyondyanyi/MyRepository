1.模式
	模式是一条由三部分组成的规则：
			一个特定环境+一个问题+一个解决方案
	核心思想：
			进行设计的复用
			
2.设计模式
		描述了定制化的相互通信的对象和类，以解决特定环境中的通用设计问题
3.体系结构模式
		对系统的高层设计，是从一个较高的层次来考虑组成系统的构建。又被称为架构模式、体系结构风格
		
		
		
体系结构模式是高层模式
设计模式是中层模式
实现架构模式时可能采用多种设计模式



一：单例模式
	定义：确保一个类仅拥有一个唯一的实例，并且提供一个全局的访问点
	
	
	1.将构造方法私有化
	2.在类中声明类的实例，并将实例声明为静态
	3.对外公布一个获取该实例的方法
	##懒汉式
	public class Singleton {  
		private Singleton() {}  
		private static Singleton single=null;  
    //静态工厂方法（线程不安全）  
		public static Singleton getInstance() {  
			 if (single == null) {    
				 single = new Singleton();  
			 }    
			return single;  
		}  
	}
	
	
	#同步
	 public static synchronized Singleton getInstance() {  
             if (single == null) {    
                 single = new Singleton();  
             }    
            return single;  
    }
	
	#双重检查锁定
	public static Singleton getInstance() {  
        if (singleton == null) {    
            synchronized (Singleton.class) {    
               if (singleton == null) {    
                  singleton = new Singleton();   
               }    
            }    
        }    
        return singleton;   
    } 
	
	##静态内部类
	public class Singleton {    
		private static class LazyHolder {    
		   private static final Singleton INSTANCE = new Singleton();    
		}    
		private Singleton (){}    
		public static final Singleton getInstance() {    
		   return LazyHolder.INSTANCE;    
		}    
	} 
	
	
	//饿汉式（天生线程安全）
	public class Singleton1 {  
		private Singleton1() {}  
		private static final Singleton1 single = new Singleton1();  
		//静态工厂方法   
		public static Singleton1 getInstance() {  
			return single;  
		}  
	}
	
} 


单例模式使用场景：
	1.要求生成唯一序列号的环境
	2.在整个项目中需要一个共享访问点或共享数据
	3.创建一个对象需要消耗的资源过多
	4.需要定义大量的静态常量和静态方法

二：好的设计原则：
	单一职责原则：
		高内聚性原则
		避免相同的职责分散到不同的类中实现
		避免一个类承担过多的职责
	开闭原则：
		Open:模块的行为必须是开放的、支持扩展的，而不是僵化的
		Closed:在对模块的功能进行扩展使，不应该影响或大规模地影响已有的程序模块
		抽象化是开闭原则的关键
		对扩展开放，对修改关闭
	里氏代换原则：所有引用基类的地方必须能透明地使用其子类的对象，通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常
			里氏替换原则为继承定义的规范：
					1.子类必须完全实现父类的方法
					2.子类可以有自己的个性
					3.覆盖或实现父类的方法时输出参数可以被放大
					4.覆盖或实现父类的方法时输出结果可以被缩小
					
					1.子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
					2.子类中可以增加自己特有的方法
					3.当子类的方法重载父类的方法时，方法的前置条件（方法的形参）要比父类方法的输入参数更宽松
					4.当子类的方法实现父类的抽象方法时，方法的后置条件（方法的返回值）要比父类更严格
					
					
			里氏替换原则是对开闭原则的补充
	依赖倒转原则：
		高层模块不应该依赖低层模块，两者都应该依赖抽象
		抽象不应该依赖细节
		细节应该依赖抽象
		也可以说高层模块，低层模块，细节都应该依赖抽象
	接口隔离原则：
		一个类对另外一个类的依赖性应当是建立在最小的接口上
		客户端不应该依赖哪些它不需要的接口（方法）
	合成复用原则：
		尽量使用对象组合，而不是继承来达到复用目的
		一个新的对象通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象
		新对象通过委派调用已有对象的方法达到复用其已有功能的目的
		
		简单说：要尽量使用组合/聚合关系（黑箱复用），少用继承（白箱复用）！
		
		黑箱复用：
			1.第一种：不用继承，类中直接新增需要复用的类的实例即可
			2.在第一种的基础上将类属性换成接口
		白箱复用：
			直接继承，耦合度高
	迪米特原则：
		要求一个软件实体应当尽可能少的与其他实体发生相互作用
		简单说：
			最少知识原则；
				不要和“陌生人”说话
				只与你的直接朋友通信
				每一个软件单位对其他的单位都只有最少的知识，而且局限于哪些与本单位密切相关的软件单位
		如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用
		
		
		
三：策略模式：
	1.将每一个一系列的算法封装起来
	2.而且使它们还可以相互替换




四：工厂方法模式：
	简单工厂模式、工厂模式、抽象工厂模式
	定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类
	
	抽象工厂模式：
		优点：封装性；产品族内的约束为非公开状态
		缺点：产品族扩展非常困难
		使用场景：一个对象族（或是一组没有任何关系的对象）都有相同的约束，则可以使用抽象工厂模式
		
		
五：模板方法模式：
			
		
	
六：适配器模式
		
	意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

	主要解决：主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。

	何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）

	如何解决：继承或依赖（推荐）。

	关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。

	应用实例： 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。

	优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。

	缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。

	使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。

	注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。
			
		
七：迭代器模式
	
	   迭代器模式（Iterator），提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示。

八：责任链模式
	
	意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

	主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。

	何时使用：在处理消息的时候以过滤很多道。

	如何解决：拦截的类都实现统一接口。

	关键代码：Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。

	应用实例： 1、红楼梦中的"击鼓传花"。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。

	优点： 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。

	缺点： 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。

	使用场景： 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。

	注意事项：在 JAVA WEB 中遇到很多应用。
		
		